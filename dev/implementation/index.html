<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Implementation · Qumulants.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Qumulants.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li class="is-active"><a class="tocitem" href>Implementation</a><ul class="internal"><li><a class="tocitem" href="#Hilbert-spaces"><span>Hilbert spaces</span></a></li><li><a class="tocitem" href="#Operators-(a.k.a.-*q*-numbers)"><span>Operators (a.k.a. <em>q</em>-numbers)</span></a></li><li><a class="tocitem" href="#Symbolic-parameters-(a.k.a.-*c*-numbers)"><span>Symbolic parameters (a.k.a. <em>c</em>-numbers)</span></a></li><li><a class="tocitem" href="#Deriving-Heisenberg-equations-and-simplification"><span>Deriving Heisenberg equations and simplification</span></a></li><li><a class="tocitem" href="#Cumulant-expansion"><span>Cumulant expansion</span></a></li><li><a class="tocitem" href="#Numerical-solution"><span>Numerical solution</span></a></li></ul></li><li><a class="tocitem" href="../theory/">Theoretical background</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li><a class="tocitem" href="../correlation/">Correlation functions and spectra</a></li><li><a class="tocitem" href="../api/">API</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/single-atom-laser-spectrum/">Spectrum of a single-atom laser</a></li><li><a class="tocitem" href="../examples/mollow/">Mollow Triplet</a></li><li><a class="tocitem" href="../examples/many-atom-laser/">Many-atom laser</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Implementation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Implementation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/david-pl/Qumulants.jl/blob/master/docs/src/implementation.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Implementation"><a class="docs-heading-anchor" href="#Implementation">Implementation</a><a id="Implementation-1"></a><a class="docs-heading-anchor-permalink" href="#Implementation" title="Permalink"></a></h1><p>Let&#39;s take a closer look at each step involved from defining a system to arriving at a numerical solution of the underlying time dynamics.</p><h2 id="Hilbert-spaces"><a class="docs-heading-anchor" href="#Hilbert-spaces">Hilbert spaces</a><a id="Hilbert-spaces-1"></a><a class="docs-heading-anchor-permalink" href="#Hilbert-spaces" title="Permalink"></a></h2><p>The first step in treating a system with <strong>Qumulants.jl</strong> is to specify the Hilbert space on which the system is defined. There are two types of Hilbert spaces implemented, namely <a href="../api/#Qumulants.FockSpace"><code>FockSpace</code></a> and <a href="../api/#Qumulants.NLevelSpace"><code>NLevelSpace</code></a>. The first describes systems whose operators follow the fundamental bosonic commutation relations (such as the quantum harmonic oscillator), whereas the latter describes systems consisting of a finite number of energy levels with an arbitrary energy difference in between (such as atoms).</p><p>A <a href="../api/#Qumulants.FockSpace"><code>FockSpace</code></a> simply needs a name in order to be defined:</p><pre><code class="language-julia">hf = FockSpace(:fock1)</code></pre><p><a href="../api/#Qumulants.NLevelSpace"><code>NLevelSpace</code></a> requires a name as well as labels for the energy levels. For example</p><pre><code class="language-julia">h_atom = NLevelSpace(:atom, (:g,:e))</code></pre><p>defines an <a href="../api/#Qumulants.NLevelSpace"><code>NLevelSpace</code></a> with the name <code>:atom</code> and the two levels labeled by <code>:g</code> and <code>:e</code>, respectively. Note that the levels can be labeled by (almost) anything. For example, <code>NLevelSpace(:two_level, (1,2))</code> would define a Hilbert space describing a system with the two discrete energy levels labeled by <code>1</code> and <code>2</code>. Specifically for numbers, there is also the short-hand method to write <code>NLevelSpace(:five_level, 5)</code> which creates a system with levels <code>1:5</code>. Note that by default the first level in the list of all levels is designated as the ground state. This can be changed by specifying the ground state explicitly as a third argument to <a href="../api/#Qumulants.NLevelSpace"><code>NLevelSpace</code></a>, e.g. <code>NLevelSpace(:four_level, 4, 2)</code> would designate the state <code>2</code> as the ground state. The ground state projector will be eliminated during simplification (see below).</p><p>Composite systems are generally described by a <a href="../api/#Qumulants.ProductSpace"><code>ProductSpace</code></a>, i.e. a Hilbert space that consists of multiple subspaces. Each subspace is either a <a href="../api/#Qumulants.FockSpace"><code>FockSpace</code></a> or an <a href="../api/#Qumulants.NLevelSpace"><code>NLevelSpace</code></a>. They can be created using the <a href="../api/#Qumulants.tensor"><code>tensor</code></a> function or the unicode symbol <a href="../api/#Qumulants.:⊗"><code>⊗</code></a> [\otimes]. For example</p><pre><code class="language-julia">h_prod1 = tensor(hf, h_atom)
h_prod2 = tensor(h_prod1, NLevelSpace(:three_level, 3))
h_prod3 = tensor(hf, h_atom, NLevelSpace(:three_level, 3)) # == h_prod2</code></pre><p>creates two product spaces. The first, <code>h_prod1</code>, consists of the previously defined <code>FockSpace(:fock1)</code> and <code>NLevelSpace(:atom, (:g,:e))</code>. The second one, <code>h_prod2</code>, adds in another <code>NLevelSpace(:three_level, 3)</code>. In principle arbitrarily many systems can be combined this way.</p><h2 id="Operators-(a.k.a.-*q*-numbers)"><a class="docs-heading-anchor" href="#Operators-(a.k.a.-*q*-numbers)">Operators (a.k.a. <em>q</em>-numbers)</a><a id="Operators-(a.k.a.-*q*-numbers)-1"></a><a class="docs-heading-anchor-permalink" href="#Operators-(a.k.a.-*q*-numbers)" title="Permalink"></a></h2><p>Once the Hilbert space of the system has been defined, we can proceed by defining operators, or <em>q</em>-numbers, on them. They are the fundamental building blocks of symbolic expressions in <strong>Qumulants.jl</strong>. Again, there are essentially two kinds of operators implemented: the quantum harmonic destruction operator <a href="../api/#Qumulants.Destroy"><code>Destroy</code></a> which acts on a <a href="../api/#Qumulants.FockSpace"><code>FockSpace</code></a>, as well as a <a href="../api/#Qumulants.Transition"><code>Transition</code></a> operator which describes a transition between any two levels on an <a href="../api/#Qumulants.NLevelSpace"><code>NLevelSpace</code></a>. Of course, these operators can only be defined on the corresponding Hilbert spaces.</p><p>Here are a few examples:</p><pre><code class="language-julia">hf = FockSpace(:fock)
a = Destroy(hf, :a)

h_atom = NLevelSpace(:atom,(:g,:e))
σge = Transition(h_atom, :σ, :g, :e)
σ = Transition(h_atom, :σ)
@assert isequal(σge, σ(:g,:e)) # true</code></pre><p>As you can see, the destruction operator <a href="../api/#Qumulants.Destroy"><code>Destroy</code></a> is created on a <a href="../api/#Qumulants.FockSpace"><code>FockSpace</code></a> and given a name. The transition operator, however, additionally requires you to specify the levels between which it describes the transition. Defining a transition without levels specified creates a callable instance which needs to be called with valid level labels before one can actually use it in any algebraic expressions. Note that in Bra-Ket notation, the transition operator <code>Transition(h, i, j)</code> is simply <span>$|i\rangle \langle j|$</span>. Note that the bosonic creation operator is simply given by the <code>adjoint</code> of <a href="../api/#Qumulants.Destroy"><code>Destroy</code></a>.</p><p>These fundamental operators are all of the type <a href="../api/#Qumulants.QSym"><code>QSym</code></a>, which are the basic symbolic building blocks for the noncommutative algebra used in <strong>Qumulants.jl</strong>. They can be combined with standard algebraic functions in expression trees, which are implemented as <a href="../api/#Qumulants.QTerm"><code>QTerm</code></a>.</p><pre><code class="language-julia">ex_fock = 0.1*a&#39;*a
ex_trans = im*(σ(:g,:e) - σ(:e,:g))</code></pre><p>Note that only operators that are defined on the same Hilbert space can be algebraically combined.</p><p>In composite systems, we also need to specify on which subsystem the respective operator acts. This information is important as operators acting on different subsystems commute with one another, but operators acting on the same one do not. When multiplying together operators in a composite systems, they are automatically ordered according to the order of Hilbert spaces. It&#39;s specified by an additional argument when creating operators.</p><pre><code class="language-julia">h_prod = FockSpace(:fock1) ⊗ FockSpace(:fock2)
a = Destroy(h_prod,:a,1)
b = Destroy(h_prod,:b,2)
a*b # a*b
b*a # a*b
a&#39;*b*a # a&#39;*a*b</code></pre><p>If a subspace occurs only once in a <a href="../api/#Qumulants.ProductSpace"><code>ProductSpace</code></a>, the choice on which an operator acts is unique and can therefore be omitted on construction.</p><pre><code class="language-julia">h_prod = FockSpace(:fock1) ⊗ FockSpace(:fock2) ⊗ NLevelSpace(:atom,(:g,:e))
σ = Transition(h_prod, :σ) # no need to specify acts_on</code></pre><p>For convenience, there is also a macro that can be used to construct operators:</p><pre><code class="language-julia">h = FockSpace(:fock) ⊗ NLevelSpace(:two_level, 2)
@qnumbers a::Destroy(h) σ::Transition(h)
ex = a&#39;*σ(1,2) + a*σ(2,1)</code></pre><h2 id="Symbolic-parameters-(a.k.a.-*c*-numbers)"><a class="docs-heading-anchor" href="#Symbolic-parameters-(a.k.a.-*c*-numbers)">Symbolic parameters (a.k.a. <em>c</em>-numbers)</a><a id="Symbolic-parameters-(a.k.a.-*c*-numbers)-1"></a><a class="docs-heading-anchor-permalink" href="#Symbolic-parameters-(a.k.a.-*c*-numbers)" title="Permalink"></a></h2><p>Commutative numbers (<em>c</em>-numbers) are represented by <code>SymbolicUtils.Sym</code> from the <a href="https://github.com/JuliaSymbolics/SymbolicUtils.jl"><strong>SymbolicUtils.jl</strong></a> package and a custom subtype to <code>Number</code> called <a href="../api/#Qumulants.CNumber"><code>CNumber</code></a>. They are generally assumed to be complex numbers and can be defined with the <a href="../api/#Qumulants.cnumbers"><code>cnumbers</code></a> function or the corresponding macro <a href="../api/#Qumulants.@cnumbers"><code>@cnumbers</code></a>. You can use them together with <em>q</em>-numbers to build symbolic expressions describing the Hamiltonian, e.g.</p><pre><code class="language-julia">h = FockSpace(:fock)
@cnumbers ω η
@qnumbers a::Destroy(h)
H = ω*a&#39;*a + η*(a + a&#39;)</code></pre><h2 id="Deriving-Heisenberg-equations-and-simplification"><a class="docs-heading-anchor" href="#Deriving-Heisenberg-equations-and-simplification">Deriving Heisenberg equations and simplification</a><a id="Deriving-Heisenberg-equations-and-simplification-1"></a><a class="docs-heading-anchor-permalink" href="#Deriving-Heisenberg-equations-and-simplification" title="Permalink"></a></h2><p>The equations of motion of <em>q</em>-numbers are determined by evaluating commutators. This can be done by using fundamental commutation relations in the term rewriting rules.</p><p>For the quantum harmonic oscillator destruction operator <span>$a$</span>, we have the canonical commutator</p><p class="math-container">\[[a,a^\dagger] = 1.\]</p><p>Within the framework, we choose normal ordering, which surmounts to the rewriting rule</p><p class="math-container">\[a a^\dagger ~\Rightarrow~ a^\dagger a +1.\]</p><p>For transition operators <span>$\sigma^{ij}$</span> denoting a transition from level <span>$j$</span> to level <span>$i$</span>, on the other hand, we have a rule for products,</p><p class="math-container">\[\sigma^{ij}\sigma^{kl} ~\Rightarrow~ \delta_{jk}\sigma^{il},\]</p><p>which is implemented as rewriting rule just so. Additionally, we use the fact that in a system with levels <span>$\{1,...,n\}$</span></p><p class="math-container">\[\sum_{j=1}^n \sigma^{jj} = 1\]</p><p>in order to eliminate the projector on the ground state. This reduces the amount of equations required for each <a href="../api/#Qumulants.NLevelSpace"><code>NLevelSpace</code></a> by 1. Note that, as mentioned before, the ground state is by default chosen to be the first (but this can be changed). Hence, the default rewriting rule to eliminate the ground-state projector is</p><p class="math-container">\[\sigma^{11} ~\Rightarrow~ 1 - \sum_{j=2}^n \sigma^{jj}.\]</p><p>These rules are applied automatically when deriving Heisenberg equations for <em>q</em>-numbers. If you manually want to apply them to an expression you can use <a href="../api/#Qumulants.qsimplify"><code>qsimplify</code></a>:</p><pre><code class="language-julia">h = FockSpace(:fock)
@qnumbers a::Destroy(h)
qsimplify(a*a&#39;) # returns a&#39;*a + 1</code></pre><p>In order to derive equations of motion, you need to specify a Hamiltonian and the operator (or a list of operators) of which you want to derive the Heisenberg equations and pass them to <a href="../api/#Qumulants.heisenberg"><code>heisenberg</code></a>.</p><pre><code class="language-julia">@cnumbers ω η
H = ω*a&#39;*a + η*(a + a&#39;) # Driven cavity Hamiltonian
he = heisenberg([a, a&#39;*a], H)</code></pre><p>\begin{align} \frac{d}{dt} a =&amp; -1.0 i \eta -1.0 i \omega a \\
\frac{d}{dt} a^\dagger a =&amp; -1.0 i \eta a^\dagger + 1.0 i \eta a \end{align}</p><p>To add decay to the system, you can pass an additional list of operators corresponding to the collapse operators describing the respective decay. For example, <code>heisenberg(a, H, [a]; rates=[κ])</code> would derive the equations of a cavity that is also subject to decay at a rate <code>κ</code>. Note that quantum noise is neglected, however (see the <a href="../theory/#theory">theory section</a>).</p><p>The equations resulting from the call to <a href="../api/#Qumulants.heisenberg"><code>heisenberg</code></a> are stored as an instance of <a href="../api/#Qumulants.HeisenbergEquation"><code>HeisenbergEquation</code></a>, which stores the left-hand-side and the right-hand-side of the equations together with additional information such as the system Hamiltonian.</p><h2 id="Cumulant-expansion"><a class="docs-heading-anchor" href="#Cumulant-expansion">Cumulant expansion</a><a id="Cumulant-expansion-1"></a><a class="docs-heading-anchor-permalink" href="#Cumulant-expansion" title="Permalink"></a></h2><p>Averaging (using <a href="../api/#Qumulants.average"><code>average</code></a>) and the <a href="../api/#Qumulants.cumulant_expansion"><code>cumulant_expansion</code></a> are essential to convert the system of <em>q</em>-number equations to <em>c</em>-number equations. Averaging alone converts any operator product to a <em>c</em>-number, yet you will not arrive at a closed set of equations without truncating at a specific order. An average is stored as a symbolic expression. Specifically, the average of an operator <code>op</code> is internally represented by <code>SymbolicUtils.Term{AvgSym}(average, [op])</code>.</p><p>The order of an average is given by the number of constituents in the product. For example</p><pre><code class="language-julia">h = FockSpace(:fock)
@qnumbers a::Destroy(h)

avg1 = average(a)
get_order(avg1) # 1

avg2 = average(a&#39;*a)
get_order(avg2) # 2</code></pre><p>The cumulant expansion can then be used to express any average by averages up to a specified order (see also the <a href="../theory/#theory">theory section</a>):</p><pre><code class="language-julia">cumulant_expansion(avg2, 1)
average(a&#39;*a, 1) # short-hand for cumulants_expansion(average(a&#39;*a), 1)</code></pre><p>When applying this to a system of equations, you obtain a set of <em>c</em>-number differential equations.</p><pre><code class="language-julia">he_avg = average(he,2)</code></pre><p>\begin{align} \frac{d}{dt} \langle a\rangle  =&amp; -1.0 i \eta -1.0 i \omega \langle a\rangle  \\
\frac{d}{dt} \langle a^\dagger  a\rangle  =&amp; -1.0 i \eta \langle a^\dagger\rangle  + 1.0 i \eta \langle a\rangle  \end{align}</p><p>Before you can actually solve the system of equations, you need to ensure that it is complete, i.e. there are no averages missing. This can be checked with <a href="../api/#Qumulants.find_missing"><code>find_missing</code></a>. Alternatively, you can automatically complete a system of equations using the <a href="../api/#Qumulants.complete"><code>complete</code></a> function which will internally use <a href="../api/#Qumulants.find_missing"><code>find_missing</code></a> to look for missing averages and derive equations for those.</p><h2 id="Numerical-solution"><a class="docs-heading-anchor" href="#Numerical-solution">Numerical solution</a><a id="Numerical-solution-1"></a><a class="docs-heading-anchor-permalink" href="#Numerical-solution" title="Permalink"></a></h2><p>Finally, in order to actually solve a system of equations, we need to generate a function that can be used in the <a href="https://github.com/SciML/OrdinaryDiffEq.jl"><strong>OrdinaryDiffEq.jl</strong></a> package. This is done using the <a href="../api/#Qumulants.build_ode"><code>build_ode</code></a> function, which generates an <code>Expr</code> that can be evaluated, or the <a href="../api/#Qumulants.generate_ode"><code>generate_ode</code></a> which calls <code>Meta.eval</code> on the result of <a href="../api/#Qumulants.build_ode"><code>build_ode</code></a>. Note that the latter can be especially useful when you want to save a function for later usage, since you can simply convert it to a <code>string</code> and write it to a file.</p><pre><code class="language-julia">ps = (ω, η)
meta_f = build_ode(he_avg, ps)
using MacroTools; MacroTools.striplines(meta_f)</code></pre><pre class="documenter-example-output">:((du, u, p, t)-&gt;begin
          begin
              begin
                  du[1] = (-1.0im) * p[2] + (-1.0im) * p[1] * u[1]
                  du[2] = (-1.0im) * p[2] * conj(u[1]) + (1.0im) * p[2] * u[1]
              end
          end
          return nothing
      end)</pre><p>Note that in addition to the system, we also need to pass a list of symbolic parameters. The order in that list is important as it will correspond to the order in which parameters need to be passed. Similarly, the solution vector will have entries in the order of the left-hand-side of the equations. The resulting function is of the form <code>f(du,u,p,t)</code>, which is precisely the format required in <a href="https://github.com/SciML/OrdinaryDiffEq.jl"><strong>OrdinaryDiffEq.jl</strong></a>. We can solve it as follows</p><pre><code class="language-julia">using OrdinaryDiffEq
f = generate_ode(he_avg, ps) # Meta.eval(meta_f)
p0 = (1.0, 0.1) # (ω, η) in that order
u0 = zeros(ComplexF64, length(he_avg))
prob = ODEProblem(f,u0,(0.0,1.0),p0)
sol = solve(prob, RK4())</code></pre><p>Now, the state of the system at each time-step is stored in <code>sol.u</code>. As mentioned above, the order of the solution is the same as in the left-hand-side of <code>he_avg</code>. For example, <code>sol.u[end][1]</code> corresponds to <span>$\langle a \rangle$</span> at the final time. In large systems it might be tedious to keep track of the order of the expectation values, especially when using <a href="../api/#Qumulants.complete"><code>complete</code></a>. For convenience, you can use <a href="../api/#Qumulants.get_solution"><code>get_solution</code></a> in such a case.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Introduction</a><a class="docs-footer-nextpage" href="../theory/">Theoretical background »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 24 February 2021 14:03">Wednesday 24 February 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
