var documenterSearchIndex = {"docs":
[{"location":"api/#API-1","page":"API","title":"API","text":"","category":"section"},{"location":"api/#API:-Hilbert-Spaces-1","page":"API","title":"Hilbert Spaces","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"HilbertSpace","category":"page"},{"location":"api/#Qumulants.HilbertSpace","page":"API","title":"Qumulants.HilbertSpace","text":"HilbertSpace\n\nAbstract type for representing Hilbert spaces.\n\n\n\n\n\n","category":"type"},{"location":"api/#","page":"API","title":"API","text":"ProductSpace","category":"page"},{"location":"api/#Qumulants.ProductSpace","page":"API","title":"Qumulants.ProductSpace","text":"ProductSpace <: HilbertSpace\n\nStores a composite HilbertSpace consisting of multiple subspaces. Generally created by computing the tensor product ⊗ of subspaces.\n\n\n\n\n\n","category":"type"},{"location":"api/#","page":"API","title":"API","text":"FockSpace","category":"page"},{"location":"api/#Qumulants.FockSpace","page":"API","title":"Qumulants.FockSpace","text":"FockSpace <: HilbertSpace\n\nHilbertSpace defining a Fock space for bosonic operators. See also: Destroy, Create\n\n\n\n\n\n","category":"type"},{"location":"api/#","page":"API","title":"API","text":"NLevelSpace","category":"page"},{"location":"api/#Qumulants.NLevelSpace","page":"API","title":"Qumulants.NLevelSpace","text":"NLevelSpace <: HilbertSpace\nNLevelSpace(name::Symbol,levels,GS=1)\n\nDefine a HilbertSpace for an object consisting of N discrete energy levels. The given levels must be an integer specifying the number of levels, or an iterable collection of levels. The argument GS specifies which state should be treated as ground state and is rewritten using population conservation during simplification. See also: Transition\n\nExamples:\n\njulia> ha = NLevelSpace(:a,3)\nℋ(a)\n\njulia> ha = NLevelSpace(:a,(:g,:e))\nℋ(a)\n\n\n\n\n\n","category":"type"},{"location":"api/#","page":"API","title":"API","text":"⊗","category":"page"},{"location":"api/#Qumulants.:⊗","page":"API","title":"Qumulants.:⊗","text":"⊗(spaces::HilbertSpace...)\n\nCreate a ProductSpace consisting of multiple subspaces.\n\nExamples\n\njulia> hf = FockSpace(:f)\nℋ(f)\n\njulia> ha = NLevelSpace(:a,2)\nℋ(a)\n\njulia> h = hf⊗ha\nℋ(f) ⊗ ℋ(a)\n\n\n\n\n\n","category":"function"},{"location":"api/#API:-Operators-1","page":"API","title":"Operators","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"AbstractOperator","category":"page"},{"location":"api/#Qumulants.AbstractOperator","page":"API","title":"Qumulants.AbstractOperator","text":"AbstractOperator\n\nAbstract type representing any expression involving operators.\n\n\n\n\n\n","category":"type"},{"location":"api/#","page":"API","title":"API","text":"BasicOperator","category":"page"},{"location":"api/#Qumulants.BasicOperator","page":"API","title":"Qumulants.BasicOperator","text":"BasicOperator <: AbstractOperator\n\nAbstract type representing fundamental operator types.\n\n\n\n\n\n","category":"type"},{"location":"api/#","page":"API","title":"API","text":"OperatorTerm","category":"page"},{"location":"api/#Qumulants.OperatorTerm","page":"API","title":"Qumulants.OperatorTerm","text":"OperatorTerm <: AbstractOperator\n\nSymbolic expression tree consisting of AbstractOperator and Number arguments.\n\n\n\n\n\n","category":"type"},{"location":"api/#","page":"API","title":"API","text":"Destroy","category":"page"},{"location":"api/#Qumulants.Destroy","page":"API","title":"Qumulants.Destroy","text":"Destroy <: BasicOperator\n\nBosonic operator on a FockSpace representing the quantum harmonic oscillator annihilation operator.\n\n\n\n\n\n","category":"type"},{"location":"api/#","page":"API","title":"API","text":"Create","category":"page"},{"location":"api/#Qumulants.Create","page":"API","title":"Qumulants.Create","text":"Create <: BasicOperator\n\nBosonic operator on a FockSpace representing the quantum harmonic oscillator creation operator.\n\n\n\n\n\n","category":"type"},{"location":"api/#","page":"API","title":"API","text":"Transition","category":"page"},{"location":"api/#Qumulants.Transition","page":"API","title":"Qumulants.Transition","text":"Transition <: BasicOperator\nTransition(h::NLevelSpace,name::Symbol,i,j)\n\nFundamental operator defining a transition from level j to level i on a NLevelSpace. The notation corresponds to Dirac notation, i.e. the above is equivalent to |i⟩⟨j|.\n\nExamples\n\njulia> ha = NLevelSpace(:a,(:g,:e))\nℋ(a)\n\njulia> σ = Transition(ha,:σ,:g,:e)\nσge\n\n\n\n\n\n","category":"type"},{"location":"api/#API:-Heisenberg-1","page":"API","title":"Heisenberg","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"heisenberg","category":"page"},{"location":"api/#Qumulants.heisenberg","page":"API","title":"Qumulants.heisenberg","text":"heisenberg(ops::Vector,H::AbstractOperator)\nheisenberg(op::AbstractOperator,H::AbstractOperator)\n\nCompute a set of Heisenberg equations of the operators in ops under the Hamiltonian H.\n\n\n\n\n\nheisenberg(ops::Vector,H::AbstractOperator,J::Vector;\n        Jdagger::Vector=adjoint.(J),rates=ones(length(J)))\nheisenberg(op::AbstractOperator,H::AbstractOperator,J::Vector;\n        Jdagger::Vector=adjoint.(J),rates=ones(length(J)))\n\nCompute the set of equations for the operators in ops under the Hamiltonian H and with loss operators contained in J. The resulting equation is equivalent to the Quantum-Langevin equation where noise is neglected.\n\nArguments\n\n*ops::Vector{<:AbstractVector}: The operators of which the equations are to be computed. *H::AbstractOperatr: The Hamiltonian describing the reversible dynamics of the     system. *J::Vector{<:AbstractOperator}: A vector containing the collapse operators of     the system. A term of the form     sum_i J_i^dagger O J_i - frac12left(J_i^dagger J_i O + OJ_i^dagger J_iright)     is added to the Heisenberg equation.\n\nOptional argumentes\n\n*Jdagger::Vector=adjoint.(J): Vector containing the hermitian conjugates of     the collapse operators. *rates=ones(length(J)): Decay rates corresponding to the collapse operators in J.\n\n\n\n\n\n","category":"function"},{"location":"api/#","page":"API","title":"API","text":"commutator","category":"page"},{"location":"api/#Qumulants.commutator","page":"API","title":"Qumulants.commutator","text":"commutator(a,b; simplify=true, kwargs...)\n\nComputes the commutator a*b - b*a of a and b. If simplify is true, the result is simplified using the simplify_operators function. Further keyword arguments are passed to simplification.\n\n\n\n\n\n","category":"function"},{"location":"api/#","page":"API","title":"API","text":"acts_on","category":"page"},{"location":"api/#Qumulants.acts_on","page":"API","title":"Qumulants.acts_on","text":"acts_on(op::AbstractOperator)\n\nShows on which Hilbert space op acts. For BasicOperator types, this returns an Integer, whereas for a OperatorTerm it returns a Vector{Int} whose entries specify all subspaces on which the expression acts.\n\n\n\n\n\n","category":"function"},{"location":"api/#API:-Differential-equations-1","page":"API","title":"Differential Equations","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"AbstractEquation","category":"page"},{"location":"api/#Qumulants.AbstractEquation","page":"API","title":"Qumulants.AbstractEquation","text":"Abstract type for equations.\n\n\n\n\n\n","category":"type"},{"location":"api/#","page":"API","title":"API","text":"DifferentialEquation","category":"page"},{"location":"api/#Qumulants.DifferentialEquation","page":"API","title":"Qumulants.DifferentialEquation","text":"DifferentialEquation{LHS,RHS,H,J,R} <: AbstractEquation{LHS,RHS}\nDifferentialEquation(lhs,rhs,H,J,rates)\n\nType defining a system of differential equations, where lhs is a vector of derivatives and rhs is a vector of expressions. In addition, it keeps track of the Hamiltonian, the collapse operators and the corresponding decay rates of the system.\n\nFields\n\n*lhs: Vector of operators or averages of which the derivatives are taken. *rhs: Vector of expressions to which the derivatives are equal. *hamiltonian: Operator defining the system Hamiltonian. *jumps: Vector of operators specifying the decay processes. *rates: Decay rates corresponding to the jumps.\n\n\n\n\n\n","category":"type"},{"location":"api/#API:-Symbolic-numbers-1","page":"API","title":"Symbolic Numbers","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"SymbolicNumber","category":"page"},{"location":"api/#Qumulants.SymbolicNumber","page":"API","title":"Qumulants.SymbolicNumber","text":"SymbolicNumber <: Number\n\nAbstract type for all symbolic numbers, i.e. Parameter, Average and corresponding expression trees.\n\n\n\n\n\n","category":"type"},{"location":"api/#","page":"API","title":"API","text":"NumberTerm","category":"page"},{"location":"api/#Qumulants.NumberTerm","page":"API","title":"Qumulants.NumberTerm","text":"NumberTerm <: SymbolicNumber\n\nExpression tree consisting of SymbolicNumber variables.\n\n\n\n\n\n","category":"type"},{"location":"api/#","page":"API","title":"API","text":"Parameter","category":"page"},{"location":"api/#Qumulants.Parameter","page":"API","title":"Qumulants.Parameter","text":"Parameter <: SymbolicNumber\n\nA parameter represented as a symbolic. See also: parameters, @parameters\n\n\n\n\n\n","category":"type"},{"location":"api/#","page":"API","title":"API","text":"parameters","category":"page"},{"location":"api/#Qumulants.parameters","page":"API","title":"Qumulants.parameters","text":"parameters(symbols::Symbol...)\nparamters(s::String)\n\nCreate symbolic parameters.\n\nExpamples\n\njulia> ps = parameters(:a, :b)\n(a, b)\n\njulia> parameters(\"a b\") == ps\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#","page":"API","title":"API","text":"@parameters","category":"page"},{"location":"api/#Qumulants.@parameters","page":"API","title":"Qumulants.@parameters","text":"@parameters(ps...)\n\nConvenience macro to quickly define symbolic parameters.\n\nExamples\n\njulia> @parameters ω κ\n(ω, κ)\n\n\n\n\n\n","category":"macro"},{"location":"api/#API:-Simplify-1","page":"API","title":"Simplification","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"simplify_operators","category":"page"},{"location":"api/#Qumulants.simplify_operators","page":"API","title":"Qumulants.simplify_operators","text":"simplify_operators(op::AbstractOperator; rewriter=default_operator_simplifier(), kwargs...)\n\nSimplify an operator through standard algebraic rewriting, as well as using fundamental commutation relations.\n\nArguments\n\n===========\n\nop: The operator expression to be simplified.\nrewriter: The rewriter used.\nkwargs: Further arguments passed to SymbolicUtils.simplify.\n\n\n\n\n\n","category":"function"},{"location":"api/#","page":"API","title":"API","text":"simplify_constants","category":"page"},{"location":"api/#Qumulants.simplify_constants","page":"API","title":"Qumulants.simplify_constants","text":"simplify_constants(t::NumberTerm;kwargs...)\n\nStandard simplification for SymbolicNumber types. Converts to a SymbolicUtils expression and uses its standard simplification routines for symbolic number variables.\n\n\n\n\n\n","category":"function"},{"location":"api/#","page":"API","title":"API","text":"expand","category":"page"},{"location":"api/#Qumulants.expand","page":"API","title":"Qumulants.expand","text":"expand(ex; rewriter=defualt_expand_simplifier(), kwargs...)\n\nSimple wrapper around SymbolicUtils.simplify that uses a rewriter such that expressions are expanded.\n\nArguments\n\n===========\n\nex: The expression to be expanded.\nrewriter: The used rewriter.\nkwargs: Further arguments passed to SymbolicUtils.simplify.\n\nExamples\n\njulia> @parameters p q r\n(p, q, r)\n\njulia> ex = p*(q+r) + (q+p)*(r+q)\n((p*(q+r))+((q+p)*(r+q)))\n\njulia> expand(ex)\n((p*q)+(p*r)+(q*r)+(p*r)+(q*q)+(p*q))\n\n\n\n\n\n","category":"function"},{"location":"api/#","page":"API","title":"API","text":"substitute","category":"page"},{"location":"api/#Qumulants.substitute","page":"API","title":"Qumulants.substitute","text":"substitute(arg, subs; simplify=true)\n\nSubstitute the symbolic argument, i.e. any subtype to AbstractOperator or SymbolicNumber according to the substitutions stored in a Dict. Also works on DifferentialEquation. If simplify=true, the output is simplified.\n\nExamples\n\njulia> @parameters p\n(p,)\n\njulia> substitute(p, Dict(p=>2))\n2\n\n\n\n\n\n","category":"function"},{"location":"api/#API:-Average-1","page":"API","title":"Average","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"Average","category":"page"},{"location":"api/#Qumulants.Average","page":"API","title":"Qumulants.Average","text":"Average <: SymbolicNumber\n\nSymbolic number representing the average over an operator. See also: average\n\n\n\n\n\n","category":"type"},{"location":"api/#","page":"API","title":"API","text":"average","category":"page"},{"location":"api/#Qumulants.average","page":"API","title":"Qumulants.average","text":"average(::AbstractOperator)\naverage(::AbstractOperator,order::Int)\n\nCompute the average of an operator. If order is given, the cumulant_expansion up to that order is computed immediately.\n\n\n\n\n\naverage(::DifferentialEquation;multithread=false)\naverage(::DifferentialEquation,order::Int;multithread=false)\n\nCompute the average of a DifferentialEquation (or a set of equations). Returns a DifferentialEquation with containing the corresponding equations for averages. If order is specified, the cumulant_expansion up to that order is computed immediately. The keyword multithread specifies whether the averaging (and cumulant_expansion) should be parallelized (defaults to false).\n\n\n\n\n\n","category":"function"},{"location":"api/#","page":"API","title":"API","text":"cumulant_expansion","category":"page"},{"location":"api/#Qumulants.cumulant_expansion","page":"API","title":"Qumulants.cumulant_expansion","text":"cumulant_expansion(avg, order::Int)\n\nFor an Average of an operator, expand it in terms of moments up to order neglecting their joint cumulant.\n\nSee also: https://en.wikipedia.org/wiki/Cumulant#Joint_cumulants\n\nExamples\n\njulia> avg = average(a*b)\n⟨a*b⟩\n\njulia> cumulant_expansion(avg,1)\n(⟨a⟩*⟨b⟩)\n\njulia> avg = average(a*b*c)\n⟨a*b*c⟩\n\njulia> cumulant_expansion(avg,2)\n((⟨a*b⟩*⟨c⟩)+(⟨a*c⟩*⟨b⟩)+(⟨a⟩*⟨b*c⟩)+(-2*⟨a⟩*⟨b⟩*⟨c⟩))\n\nOptional arguments\n\n*simplify=true: Specify whether the result should be simplified. *kwargs...: Further keyword arguments being passed to simplify_constants\n\n\n\n\n\n","category":"function"},{"location":"api/#","page":"API","title":"API","text":"get_order","category":"page"},{"location":"api/#Qumulants.get_order","page":"API","title":"Qumulants.get_order","text":"get_order(arg)\n\nCompute the order of a given argument. This is the order used to decide whether something should be expanded using a cumulant_expansion method.\n\nExamples\n\njulia> get_order(a)\n1\n\njulia> get_order(a*b)\n2\n\njulia> get_order(1)\n0\n\n\n\n\n\n","category":"function"},{"location":"api/#API:-DiffEq-1","page":"API","title":"Function generation","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"build_ode","category":"page"},{"location":"api/#Qumulants.build_ode","page":"API","title":"Qumulants.build_ode","text":"build_ode(rhs::Vector, vs::Vector, ps=[], usym=:u,\n            psym=:p, tsym=:t; set_unknowns_zero::Bool=false, check_bounds::Bool=false)\n\nFrom a set of equations contained in eqs, generate a Meta.Expr containing the code for a function which can be directly passed to OrdinaryDiffEq in order to solve it. The variable vector u corresponds to the symbols provided in vs.\n\nArguments\n\n*eqs::Vector: The vector containing the right-hand side of equations. *vs::Vector: The vector containing the left-hand side of equations. *ps=[]: List of (symbolic) parameters, which are parsed into parameters     used in DiffEq functions. *usym=:u: The symbol used for the variable vector. *psym=:p: The symbol used for the parameter vector. *tsym=:t: The symbol used for the time parameter.\n\nOptional arguments\n\n*check_bounds::Bool=false: Choose whether the resulting function should contain     the @inbounds flag, which skips bounds checking for performance.\n\n\n\n\n\nbuild_ode(eqs::DifferentialEquation, ps=[], usym=:u,\n            psym=:p, tsym=:t; set_unknowns_zero::Bool=false, check_bounds::Bool=false)\n\nFrom a set of differential equationseqs of averages, generate a Meta.Expr containing the code for a function which can be directly passed to OrdinaryDiffEq in order to solve it.\n\nArguments\n\n*eqs::DifferentialEquation: The set of (average) equations. *ps=[]: List of symbolic parameters, which are parsed into parameters     used in DiffEq functions. *usym=:u: The symbol used for the variable vector. *psym=:p: The symbol used for the parameter vector. *tsym=:t: The symbol used for the time parameter.\n\nOptional arguments\n\n*check_bounds::Bool=false: Choose whether the resulting function should contain     the @inbounds flag, which skips bounds checking for performance.\n\n\n\n\n\n","category":"function"},{"location":"api/#","page":"API","title":"API","text":"generate_ode","category":"page"},{"location":"api/#Qumulants.generate_ode","page":"API","title":"Qumulants.generate_ode","text":"generate_ode(eqs::DifferentialEquation, ps=[], usym=:u,\n            psym=:p, tsym=:t; set_unknowns_zero::Bool=false, check_bounds::Bool=false)\n\nFrom a set of differential equations eqs of averages, generate a Function which can be directly used in OrdinaryDiffEq. Essentially, this calls Meta.eval on the output of the build_ode function.\n\nArguments\n\n*eqs::DifferentialEquation: The set of (average) equations. *ps=[]: List of symbolic parameters, which are parsed into parameters     used in DiffEq functions. *usym=:u: The symbol used for the variable vector. *psym=:p: The symbol used for the parameter vector. *tsym=:t: The symbol used for the time parameter.\n\nOptional arguments\n\n*check_bounds::Bool=false: Choose whether the resulting function should contain     the @inbounds flag, which skips bounds checking for performance.\n\nRelated methods\n\ngenerate_ode(eqs::Vector, vs::Vector, ps=[], usym=:u,\n            psym=:p, tsym=:t; set_unknowns_zero::Bool=false, check_bounds::Bool=false)\n\n\n\n\n\n","category":"function"},{"location":"api/#API:-Utils-1","page":"API","title":"Utility functions","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"find_missing","category":"page"},{"location":"api/#Qumulants.find_missing","page":"API","title":"Qumulants.find_missing","text":"find_missing(rhs::Vector, vs::Vector, vs_adj=adjoint.(vs), ps=[])\n\nFor a list of expressions contained in rhs, check whether all occurring symbols are contained either in the variables given in vs. If a list of parameters ps is provided, parameters that do not occur in the list ps are also added to the list. Returns a list of missing symbols.\n\n\n\n\n\n","category":"function"},{"location":"api/#","page":"API","title":"API","text":"get_symbolics","category":"page"},{"location":"api/#Qumulants.get_symbolics","page":"API","title":"Qumulants.get_symbolics","text":"get_symbolics(ex)\n\nFind all symbolic numbers occuring in ex.\n\n\n\n\n\n","category":"function"},{"location":"api/#","page":"API","title":"API","text":"get_operators","category":"page"},{"location":"api/#Qumulants.get_operators","page":"API","title":"Qumulants.get_operators","text":"get_operators(::AbstractOperator)\n\nReturn a list of all BasicOperator in an expression.\n\n\n\n\n\n","category":"function"},{"location":"api/#","page":"API","title":"API","text":"find_operators","category":"page"},{"location":"api/#Qumulants.find_operators","page":"API","title":"Qumulants.find_operators","text":"find_operators(::HilbertSpace, order; names=nothing)\n\nFind all operators that fully define a system up to the given order.\n\n\n\n\n\n","category":"function"},{"location":"api/#","page":"API","title":"API","text":"complete","category":"page"},{"location":"api/#Qumulants.complete","page":"API","title":"Qumulants.complete","text":"complete(de::DifferentialEquation)\n\nFrom a set of differential equation of averages, find all averages that are missing and derive the corresponding equations of motion.\n\n\n\n\n\n","category":"function"},{"location":"api/#","page":"API","title":"API","text":"unique_ops","category":"page"},{"location":"api/#Qumulants.unique_ops","page":"API","title":"Qumulants.unique_ops","text":"unique_ops(ops)\n\nFor a given list of operators, return only unique ones taking into account their adjoints.\n\n\n\n\n\n","category":"function"},{"location":"api/#","page":"API","title":"API","text":"fundamental_operators","category":"page"},{"location":"api/#Qumulants.fundamental_operators","page":"API","title":"Qumulants.fundamental_operators","text":"fundamental_operators(::HilbertSpace)\n\nReturn all fundamental operators for a given Hilbertspace. For example, a FockSpace only has one fundamental operator, Destroy.\n\n\n\n\n\n","category":"function"},{"location":"api/#","page":"API","title":"API","text":"transition_superscript","category":"page"},{"location":"api/#Qumulants.transition_superscript","page":"API","title":"Qumulants.transition_superscript","text":"transition_superscript(::Bool)\n\nSpecify whether the indices in a Transition operator should be printed as superscript. Default is true. If set to false, the indices corresponding to the levels are printed as subscript.\n\n\n\n\n\n","category":"function"},{"location":"#Introduction-1","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Qumulants.jl offers a practical approach to the application of the generalized cumulant expansion method in Quantum Optics: operators are often represented by matrices on a Hilbert space, where a suitable basis has been chosen. These matrices can quickly become so large that they can no longer be stored. On a more abstract level, however, operators form a noncommutative alebgra that follows fundamental commutation relations. This is where Qumulants.jl comes in. The basic working principle boils down to the following steps:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"The model (Hamiltonian) is specified.\nEquations of motion (Heisenberg equations) are symbolically derived for the system operators by using their fundamental commutation relations.\nThen follows the key step: the equations of motion for the noncommutative operators are averaged and truncated at a specified order neglecting higher-order quantum correlations using the generalized cumulant expansion method. This results in a closed set of c-number ordinary differential equations.\nFinally, the symbolic system of equations can be turned into a native Julia function which is directly usable in the DifferentialEquations.jl framework. This makes it straightforward to obtain a solution of the time dynamics of a system.","category":"page"},{"location":"#Installation-1","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Qumulants.jl is not officially released (yet) and so has to be installed directly from GitHub. This can be done with","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"|pkg> add https://github.com/david-pl/Qumulants.jl.git","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"For a full list of functions, check out the API.","category":"page"},{"location":"tutorial/#Tutorial-1","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"The basic usage is probably best illustrated with a brief example. In the following, we solve a simple model for a single-atom laser.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"We start by loading the package, defining some symbolic parameters and the photonic annihilation operator a as well as the atomic lowering operator s. This allows us to quickly write down the Hamiltonian and the collapse operators of the system with their corresponding decay rates.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"using Latexify # hide\nset_default(double_linebreak=true) # hide\nusing Qumulants\n\n# Define parameters\n@parameters Δ g γ κ ν\n\n# Define hilbert space\nhf = FockSpace(:cavity)\nha = NLevelSpace(:atom,(:g,:e))\nh = hf ⊗ ha\n\n# Define the fundamental operators\na = Destroy(h,:a)\ns = Transition(h,:σ,:g,:e)\n\n# Hamiltonian\nH = Δ*a'*a + g*(a'*s + a*s')\n\n# Collapse operators\nJ = [a,s,s']\nrates = [κ,γ,ν]\nnothing # hide","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Now, we define a list of operators of which we want to compute the Heisenberg equations. We will only consider products of two operators. This is because later we will compute the dynamics of the system up to second order.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"# Derive a set of Heisenberg equations\nops = [a'*a,s'*s,a'*s]\nhe = heisenberg(ops,H,J;rates=rates)","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"The equations derived above are differential equations for operators. In order to convert them to c-number equations, we need to average over them. To obtain a closed set of equations, we expand higher-order products to second order.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"# Average the above equations and expand to second order\nhe_avg = average(he,2)","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"The first-order contributions are always zero and can therefore be neglected. You can try adding a and s to the list of operators ops in order to see that yourself. Or, even more conveniently, you can use complete(he_avg), which will automatically find all missing averages and compute the corresponding equations.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Here, though, we will proceed by finding the missing averages, and neglecting them as zero using the substitute function.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"# Find the missing averages\nmissed = find_missing(he_avg)\n\n# Substitute them as zero\nsubs = Dict(missed .=> 0)\nhe_nophase = simplify_constants(substitute(he_avg, subs))","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Finally, we can generate Julia code from the above set of equations which can be solved directly using the OrdinaryDiffEq.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"# Generate a Julia function that to solve numerically\np = (Δ, g, γ, κ, ν)\nf = generate_ode(he_nophase,p)\n\n# Solve the system using the OrdinaryDiffEq package\nusing OrdinaryDiffEq\nu0 = zeros(ComplexF64,length(ops))\np0 = (0, 1.5, 0.25, 1, 4)\nprob = ODEProblem(f,u0,(0.0,10.0),p0)\nsol = solve(prob,RK4())\nnothing # hide","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"The photon number of our laser and the excited state population of the atom are now stored in the first two fields of sol.u.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"using Plots\nn = real.(getindex.(sol.u, 1))\npe = real.(getindex.(sol.u, 2))\nplot(sol.t, n, label=\"Photon number\", xlabel=\"t\")\nplot!(sol.t, pe, label=\"Excited state population\")\nsavefig(\"tutorial.svg\") # hide\nnothing # hide","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"(Image: Photon number and excited state population)","category":"page"}]
}
